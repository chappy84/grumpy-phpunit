{mainmatter}

# PHPUnit For Grumpy Developers
PHPUnit can look intimidating, even to just get the skeleton of a test created, due
to the immense length of its documentation and large number of configurable
options. Don't be scared though, I am here to help!

You can start with just a few of the basics before moving on to more complicated setups that include options for
skipping certain types of tests or changing default settings.

To be honest, the defaults will cover 99.999% of your testing needs.

## Installing And Configuring
Installing PHPUnit and its associated (sometimes optional) dependencies has
gotten easier and easier with each passing day. As I write this book in the
Canadian winter of 2012-2013, I have two preferred ways of installing PHPUnit that I
would recommend.

### Installing via Composer
[Composer](http://getcomposer.org/) is a command-line tool for tracking and
installing dependencies for your application. In my opinion, Composer
is transforming the way PHP developers build their PHP applications, making it easier to install dependencies
and external libraries. With all the major frameworks supporting it,
there is no reason not to use it if you are running PHP 5.3 or greater.

To install PHPUnit using Composer, once you've installed Composer itself, create a JSON file (commonly named composer.json) that tells Composer where you want it installed.

Here's an example that will install PHPUnit globally in the specified 'config' directory.

{lang : json}
    {
        "name": "phpunit",
        "description": "PHPUnit",
        "require": {
            "phpunit/phpunit": "3.7.*"
        },
        "config": {
            "bin-dir": "/usr/local/bin/"
        }
    }

Composer will also try to pull in any required dependencies, but if for
some reason they don't work, you can just add them to composer.json.

If you prefer to have PHPUnit as an actual dependency for your application,
you can create a much simplified version of that JSON file

{lang: "json"}
    {
        "require-dev": {
            "phpunit/phpunit": "3.7.*"
        }
    }

Then, if people choose to install or update your code via Composer and use the
`--dev` flag, they will get the version of PHPUnit you have specified
installed and available for use *inside* your project, in the vendor
directory.

It's a tough call. On the one hand, you don't want to force people to
install PHPUnit just to use your project. On the other hand, it does ensure
that you can update PHPUnit independent of any other versions you already had
installed.

### Installing via PEAR
[Pear](http://pear.php.net) used to be my preferred method of installation
before they made it available via Composer. In this case, installing things
can be as simple as:

{: lang }
    path/to/pear config-set auto_discover 1
    path/to/pear install pear.phpunit.de/PHPUnit

By default PEAR will try to pull in additional dependencies for PHPUnit,
but you can manually install any additional missing components via PEAR as well.

### Which One Should I Use
That depends on what additional dependencies you happen to be including. I definitely
think you should choose one method and stick with it, however, as mixing Composer and PEAR
might cause you to make mistakes and forget a package that you are likely
to need. It's worth noting that Composer installs dependencies locally by default while PEAR
installs globally by default.

In any case, consult the documentation for PHPUnit to see all the dependencies
and add-ons that are available.

## Minimum Viable Test Class
{lang : php }
    <?php
    class GrumpyTest extends PHPUnit_Framework_TestCase
    {
        public function testMinimumViableTest()
        {
            $this->assertTrue(false, "true didn't end up being false!");
        }
    }

That is what I would call a Minimum Viable Test class. All test classes
need to extend off of the base `PHPUnit_Framework_TestCase` class, although
it is common for people to create their *own* base class that extends from
this one, and then all their test cases extend from it.

All the built-in assertions that PHPUnit provides follow the same pattern:

* a type of assertion
* an expected value
* the value generated by the test
* an optional message to be displayed when the test fails

I can already tell that you are thinking "he's lying about the pattern because
it says 'assertTrue.'" In a way, you are right. PHPUnit does provide some
shortcuts to perform certain assertions. assertTrue() is one of them, along
with its counterpart assertFalse(). These shortcuts do not change the fact
that they all follow the same pattern.

For more details on all the assertions that are available to you, check
the [latest documentation](http://www.phpunit.de/manual/3.7/en/writing-tests-for-phpunit.html#writing-tests-for-phpunit.assertions).

## Making Your Tests Tell You What's Failed

### Verbose mode
You can add the option `--verbose` when running PHPUnit to get some
more detailed information about the test run. Things like skipped or
incomplete tests are important to know, especially if you are using
multiple different configuration files and are purposely skipping
some tests due to either how long they take to run or their
flakiness due to use of outside sources of information.
 
### TestDox
A friend of mine related a story to me about an experience he had in a
team he was working with:

> Today I was called in as the unit tests stopped somewhere in the beginning 
> of the unit test run. I was really blown away to see the many
> E, F, I and S characters in the overview but I was more amazed about the 
> fact that my team had no idea how to figure out which test caused
> the fatal error

Now, I mentioned that all these assertions take, as their final argument, an 
optional message to be displayed if the test fails. I cannot recommend highly
enough that you make that message mandatory when you write your own tests. A
descriptive message will go a long way towards helping you figure out exactly
which test failed, hopefully telling you why.

There is also another option that doesn't involve using the optional message
argument. You could use PHPUnit's [TestDox](http://www.phpunit.de/manual/3.7/en/other-uses-for-tests.html)
functionality. What it does is turn the name of your test methods into easily-read
strings. 

It will turn the test method name `testBankBalanceCannotGoIntoOverdraftUnlessAllowed` into "Bank balance cannot
go into overdraft unless allowed". But be careful: if you have tests that have
the same name but you append an integer to the end, TestDox does not know
that the two are different.

Here's a sample run using it.

{: lang="text"}
    $ phpunit --testdox
    PHPUnit 3.7.10 by Sebastian Bergmann.

    Configuration read from /Users/chartjes/Sites/liesitoldmykids/tests/phpunit.xml

    LieEntity
     [x] Description is not spammy
     [x] Description has swearing
     [x] Description has porn

    LieMapper
     [x] Returns lie collection
     [x] Get one record
     [x] Get correctly handles not finding lie
     [x] Get valid lies
     [x] Create new lie
     [x] Delete known created entity
     [x] Delete correctly handles null lie entity id
     [x] Delete handles no deleted rows correctly
     [x] Delete handles missing entity correctly
     [x] Update known entity
     [x] Update correctly handles bad lie entity
     [x] Update correctly handles rejecting wrong lie update

TestDox simply gives you a human-readable list of the tests that have
run. PHPUnit will still tell you what tests failed, but the TestDox
version just might make it easier.

## Configuring Run Time Options
If you run `phpunit --help` from the command line, you will see a
ridiculous number of options that are available to you. Some of them are
useful, others seem to be in there because the author was looking for
compatibility with existing tools. Here are the ones that I have found most
useful.

### Code Coverage Options
Code coverage reports are a tool you can use to figure out how much
of your code is being executed by your tests. This value is normally
expressed as a percentage as in "I have 60% code coverage for my application...
why is Chris glaring at me like that?"

You also can get what is known as the Change Risk Analysis and Predictions
metric for your code. The CRAP score (I cannot think of a more appropriate
acronym) is an indication of how complex it is. The higher the CRAP score,
the more complicated your code is.

In order to generate a code coverage report, you need to have 
[the PHP CodeCoverage component](http://github.com/sebastianbergmann/php-code-coverage)
and [XDebug](http://xdebug.org) installed. 

There are two additional options you need to consider when generating code
coverage:

Use `--coverage-clover optional/path/to/file` for generating Clover-formatted
reports that can be read by Jenkins code coverage plugins.

Clover-formatted reports can be used to examine trends over time in terms of
code coverage and lines of code added. These are extremely useful if you are trying to
make sure developers are living up to their promises of writing tests with
maximum code coverage.

Use `--coverage-html optional/path` to create a series of HTML files that you
can view in your browser to see code coverage results.

Code coverage reports are also a great tool for code reviews -- visible
proof that you might be missing some tests for a few edge cases lurking
deep inside your application.
 
### Managing Global State 
Many PHP applications make use of singletons that have static method calls,
or rely on globals and super-globals (such as `$_SESSION` or `$_POST`, etc). While there
are legitimate reasons from an architectural standpoint to use static
methods, they are kryptonite when it comes to testing. Static classes, 
attributes, and variables are also considered part of the global state.

The problem? You often have no control over when and to what values these
things can be set. PHPUnit offers you a few ways to handle this. First, 
by default, PHPUnit tries to run your tests in such a way that it isolates
any changes made to global items, so you are somewhat covered there.

If you are using PHP 5.3 or greater, PHPUnit will give you the option to
also backup and restore static attributes of user defined classes. Again,
a good practice to allow for isolated tests.

My advice to you is avoid statics as much as possible. The backup-and-restore
mechanism will increase memory usage and test execution time, and statics
are all about trying to impose immutability in a language that likes everything
to be dynamic.

However, if you do need to use them, here are some tips:

* `--no-globals-backup` will disable the default backup-and-restore $GLOBALS
* `--static-backup` will backup and restore static attributes by default
* `@backupGlobals` annotation can be used to temporarily disable the backup-and-restore functionality for globals
* `@backupStaticAttributes` does the same, but for static attributes

### Process Isolation
Sometimes you are testing functionality that needs to be isolated while
testing. Things like class autoloaders, the session super-global, and header
output can all act weirdly under normal test conditions so they need a little help
to create the proper environment.

Use the `--process-isolation` switch to tell PHPUnit to run all your tests
in their own PHP instance. This has the disadvantage of not being configurable
for individual test cases, consuming more memory, and taking longer to
execute.

## Test Environment Configuration
You'll find manually adding command-line switches when running your tests 
quickly becomes tedious. Fortunately, PHPUnit allows you to use a           
configuration file for specifying the default switches, among other         
settings. By default, PHPUnit will look for a file named either             
`phpunit.xml` or `phpunit.xml.dist` in the directory in which you run it,   
and use the values it contains to alter its own behavior.                   
                                                                            
You may need different configuration for different kinds of tests -- e.g.,  
unit tests vs. integration tests. PHPUnit allows you to indicate a specific 
configuration file using the `--configuration` switch, with an argument     
indicating the path of the configuration file.            

To execute your tests with a specific configuration file do:

{lang: text}
    /path/to/phpunit --configuration /path/to/your/phpunit.xml

### Command-Line Switches 
Command line switches can be specified in the configuration file as         
attributes of the root `phpunit` element. The following provides            
configuration for the `--backupGlobals` and `--processIsolation` switches,  
respectively:    

{ lang: xml}
    <phpunit 
        backupGlobals="true"
        processIsolation="false">
    <!-- other stuff goes here -->
    </phpunit>

[Appendix C](http://www.phpunit.de/manual/current/en/appendixes.configuration.html) of the current PHPUnit documentation covers this in more detail.
I highly recommend setting as many of the command-line switches as you can
in the configuration file so you don't forget to do it yourself. Remember,
computers are awesome at doing what you tell them to over and over again.
Humans, not so much.

### Process Isolation
If you've worked with PHP for any length of time, you become aware of
the fact that there is global state, and that the state is preserved for
the entire length of the request. In other words, if you create an 
object at any point in the request, it will be available to any other
code that resides in the same scope.

This can sometimes be a problem when running tests because you don't
want state leaking from one test to another. Things could get unpredictable
if you modify an object in one test when a subsequent test expects that object
to be unmodified.

I usually see process isolation used in PHPUnit when
running integration tests. Why? Integration tests usually consist of
manipulating real objects, not test doubles, so you must pay close
attention to their state.

To ensure process isolation for all your tests, it's as simple as passing
`--process-isolation` as a CLI option, or setting `processIsolation="true"` in
your XML configuration file. This means, by default, every single test will
be run in it's own PHP process. This means your test suite will take a
lot longer to run, so keep this in mind if you decide to do it.

If you need process isolation for all tests in a single file, you can
enforce this by putting `@runInSeparateProcess` in the docblock
for your test class.

If you only have some tests that need to be isolated, make sure to use
the annotation in the docblock for the method. That way, it is only applied
to that one method.

Another potential solution is to use separate `phpunit.xml` 
files that set process isolation as a run-time option and then
white list only the directories containing the tests that need
to be run in isolation. Conversely, make sure that your non-process-isolated
configuration file doesn't include any tests that require isolation
to work correctly.

As an example we have `phpunit-unit.xml`

{ lang: xml}
    <phpunit 
        <!-- this is our config file for unit tests -->
        processIsolation="false">
    <!-- other stuff goes here -->
    </phpunit>

and we have `phpunit-integration.xml`

{ lang: xml}
    <phpunit 
        <!-- this is our config file for integration tests -->
        processIsolation="true">
    <!-- other stuff goes here -->
    </phpunit>

Then, when you are ready to run just your unit tests you run

{ lang: text} 
    path/to/phpunit --configuration path/to/phpunit-unit.xml 

My experience has been that the multiple configuration file method
is the best way to go if you are going to write unit and integration
tests.

## Organizing Your Tests

### File System
The easiest way to organize your tests is via the file system. Create a
directory for all your tests to run in, and PHPUnit will automatically
recursively traverse the directories below your root test directory to
find tests to run.

{ lang: text}
    tests
    |-- Foo
    |   | -- Fizz
    |   |    `-- InputsTest.php
    |   | -- Buzz
    |   |    `-- RecursionTest.php
    |   `-- BazzTest.php
    `-- FooTest.php

This is normally the way I organize my tests. Like with so many things
related to programming, this is a personal preference.

Some developers prefer to bundle their tests alongside the code (think
vendor directories when installing things via Composer). Some prefer
all their tests to be in one flat directory.

Either way, it doesn't matter because PHPUnit will search all directories
you ask it to looking for files with test cases in them.

### Test Suites 
In a previous section I talked about creating an XML test suite file. You
can also specify exactly what tests you want run via XML. Let's create
a file that mirrors the structure we used above.

{ lang: xml}
    <phpunit>
        <testsuites>
            <testsuite named="Foo">
                <file>Tests/Foo/Fizz/InputsTest.php</file>
                <file>Tests/Foo/Buzz/RecursionTest.php</file>
                <file>Tests/Foo/BazzTest.php</file>
                <file>Tests/FooTest.php</file>
            </testsuite>
        </testsuites>
    </phpunit>

Test suites are a way of grouping tests together. This can be handy
if you are making changes to some code and want to first just run the
tests most likely to be impacted by the change.

To run the `Foo` test suite in the example file, you would do

{ lang: text } 
    /path/to/phpunit --testsuite Foo

You can also use the test suite functionality to "whitelist" your tests,
ensuring that only the ones you want get executed. This is handy if you
are working on a large team and have tests for code that is not quite
finished yet and therefore don't need to see those test failures.

Want to group a test suite based on directory?

{ lang: xml}
    <phpunit>
        <testsuites>
            <testsuite named="Bar">
                <directory>alpha</directory>
                <directory>beta</directory>
                <directory>gamma</directory>
            </testsuite>
        </testsuites>
    </phpunit>

PHPUnit does not require you to define test suites in the
configuration file.

### Multiple Test Suites
As you start writing a large number of tests for your application, you'll
observe some common problems: 

- some of your tests might be flaky due to integration with 3rd party services
  you have not put wrappers around.
- shared testing database servers can often get overloaded, leading to transient
  test failures.
  
These things, while regrettable, are sometimes a reality for a resource-starved
development team.

Through the use of test suites, you can create test plans
that you can choose to execute on an as-needed basis. To use the above
analogy, you might only want to run the flaky tests during the final set
of tests before a production push.

So how do we do this? First, you'd define your test suites:

{ lang: xml}
    <?xml version="1.0" encoding="UTF-8"?>
    <phpunit
        bootstrap="vendor/autoload.php"
        printerFile="vendor/whatthejeff/nyancat-phpunit-resultprinter/src/NyanCat/PHPUnit/ResultPrinter.php"
        printerClass="NyanCat\PHPunit\ResultPrinter">
        <testsuites>
            <testsuite name="unit">
                <file>LieMapperTest.php</file>
                <file>UserMapperTest.php</file>
            </testsuite>
            <testsuite name="integration">
                <file>LieEntityTest.php</file>
            </testsuite>
        </testsuites>
    </phpunit>

First, we run just the `unit` test suite

{ lang: text }
    $ phpunit --testsuite unit                                                                                                
    PHPUnit 3.7.10 by Sebastian Bergmann.

    Configuration read from /Users/chartjes/Sites/liesitoldmykids/tests/phpunit.xml

     23  -_-_-_-_-_-_-_-_-_-_-_-__,------,
     0   -_-_-_-_-_-_-_-_-_-_-_-__|  /\_/\ 
     0   -_-_-_-_-_-_-_-_-_-_-_-_~|_( ^ .^) 
         -_-_-_-_-_-_-_-_-_-_-_-_ ""  "" 


    Time: 0 seconds, Memory: 4.25Mb

    OK (23 tests, 74 assertions)

Then the `integration` test suite

{ lang: text }
    $ phpunit --testsuite integration
    PHPUnit 3.7.10 by Sebastian Bergmann.

    Configuration read from /Users/chartjes/Sites/liesitoldmykids/tests/phpunit.xml

     3   -_-__,------,
     0   -_-__|  /\_/\ 
     0   -_-_~|_( ^ .^) 
         -_-_ ""  "" 


    Time: 0 seconds, Memory: 3.75Mb

    OK (3 tests, 6 assertions)

Confident that our code is fine, let's run them both

{ lang: text }
    $ phpunit                        
    PHPUnit 3.7.10 by Sebastian Bergmann.

    Configuration read from /Users/chartjes/Sites/liesitoldmykids/tests/phpunit.xml

     26  -_-_-_-_-_-_-_-_-_-_-_-_-_-_,------,
     0   -_-_-_-_-_-_-_-_-_-_-_-_-_-_|   /\_/\ 
     0   -_-_-_-_-_-_-_-_-_-_-_-_-_-^|__( ^ .^) 
         -_-_-_-_-_-_-_-_-_-_-_-_-_-  ""  "" 


    Time: 0 seconds, Memory: 4.50Mb

    OK (26 tests, 80 assertions)

### Alternate Test Runners
By default, PHPUnit's test runner is pretty bland. It doesn't
even do red for failures or green for passes! Being up on Internet
memes, I like to use a [Nyan Cat](http://www.nyan.cat/) test runner
to display my results.

To enable it, I installed the [test runner](https://github.com/whatthejeff/nyancat-phpunit-resultprinter/)
using Composer and then altered my PHPUnit configuration file
to use it.

{: lang="xml"}
    <?xml version="1.0" encoding="UTF-8"?>
    <phpunit
        bootstrap="vendor/autoload.php"
        printerFile="vendor/whatthejeff/nyancat-phpunit-resultprinter/src/NyanCat/PHPUnit/ResultPrinter.php"
        printerClass="NyanCat\PHPunit\ResultPrinter">
        <testsuites>
            <testsuite name="Lies I Told My Kids">
                <file>LieEntityTest.php</file>
                <file>LieMapperTest.php</file>
                <file>UserMapperTest.php</file>
                <exclude>./vendor</exclude>
                <exclude>./report</exclude>
            </testsuite>
        </testsuites>
    </phpunit>

Behold, the Nyan Cat!

{: lang="text"}
    $ phpunit 
    PHPUnit 3.7.10 by Sebastian Bergmann.

    Configuration read from /Users/chartjes/Sites/liesitoldmykids/tests/phpunit.xml

     26  -_-_-_-_-_-_-_-_-_-_-_-_-_-_,------,
     0   -_-_-_-_-_-_-_-_-_-_-_-_-_-_|   /\_/\
     0   -_-_-_-_-_-_-_-_-_-_-_-_-_-^|__( ^ .^)
         -_-_-_-_-_-_-_-_-_-_-_-_-_-  ""  ""


    Time: 1 second, Memory: 4.50Mb

    OK (26 tests, 79 assertions)
