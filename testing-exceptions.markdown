# Testing Exceptions
{: lang="php" }
    <?php
    class Foo
    {
        protected $api;

        public function __construct($api)
        {
            $this->api = $api;
        }

        public function findAll()
        {
            try {
                $this->api->connect();
                $response = $this->api->getAll();
            } catch (Exception $e) {
                throw new ApiException($e->getMessage())
            }

            return $response;
        }
    }

If you're into writing what I refer to as "modern PHP", you are definitely
going to want to be using exceptions to trap all your non-fatal errors.
Code that has exceptions also needs to be tested. Never fear, PHPUnit can
show you the way.

## Testing via annotations
PHPUnit can use annotations to indicate what exceptions and messages it
is expecting to encounter when testing code. Let's create a test for our
code sample above.

{: lang="php" }
    <?php
    /**
     * Test that makes sure we are correctly triggering an
     * exception when we cannot conenct to our remote API
     *
     * @expectedException ApiException
     * @expectedExceptionMessage Cannot connect
     */
    public function testThrowsCorrectException()
    {
        $api = $this->getMockBuilder('Api')
            ->disableOriginalConstructor()
            ->getMock();
        $api->expects($this->any())
            ->method('connect')
            ->will($this->throwException(new Exception('Cannot connect')));
        $foo = new Foo($api);
        $foo->connect();
    }

PHPUnit is able to verify the exception and it's message through the use
of two annotations.

`@expectedException` is set to be the exception you are expecting to be thrown
while `@expectedExceptionMessage` should be set to the actual message you
are expecting to be generated by the exception.

There is a third annotation you can use, `@expectedExceptionCode` if you like
to have your exceptions throw messages and an associated code value.

## Testing via try-catch
If you don't want to use annotations, you can always trap them using a try-catch
block in the test itself.

{: lang="php"}
    /**
     * Test that makes sure we are correctly triggering an
     * exception when we cannot conenct to our remote API
     */
    <?php
    public function testThrowsCorrectException()
    {
        try {
            $api = $this->getMockBuilder('Api')
                ->disableOriginalConstructor()
                ->getMock();
            $api->expects($this->any())
                ->method('connect')
                ->will($this->throwException(new Exception('Cannot connect')));
            $foo = new Foo($api);
            $foo->connect();
        } catch (ApiException $e) {
            return;
        }

        $this->fail('Did not throw expected ApiException');
    }

If the code under test throws an exception, it will be caught by the `catch`
block and the test will pass. Otherwise `fail()` will cause the test to
have been considered to not have passed.
